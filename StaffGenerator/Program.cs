using Mutagen.Bethesda;
using Mutagen.Bethesda.FormKeys.SkyrimSE;
using Mutagen.Bethesda.Skyrim;
using Mutagen.Bethesda.Synthesis;
using Noggog;
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Threading.Tasks;

namespace System.Runtime.CompilerServices
{
    class IsExternalInit {
    }
}

namespace StaffGenerator
{
    record StaffData(IBookGetter Book, ISpellGetter Spell, string SpellName, string SpellEditorID, MagicSchool MagisSchool, MagicLevel MagicLevel, IWeaponGetter UnenchantedStaff, int HeartStoneCount, ushort EnchantmentAmount)
    {
        public string? EnchantmentEditorID;
        public IObjectEffectGetter? Enchantment;

        public bool EnchantmentExisted = true;

        public string? StaffEditorID;
        public IWeaponGetter? Staff;

        public bool StaffExisted = true;
    }

    enum MagicSchool
    {
        Alteration,
        Conjuration,
        Destruction,
        Illusion,
        Restoration
    };

    enum MagicLevel
    {
        Novice = 0,
        Apprentice = 25,
        Adept = 50,
        Expert = 75,
        Master = 100
    };


    public class Program
    {
        static Lazy<Settings> Settings = null!;

        public static async Task<int> Main(string[] args)
        {
            return await SynthesisPipeline.Instance
                .AddPatch<ISkyrimMod, ISkyrimModGetter>(RunPatch)
                .SetAutogeneratedSettings(
                    nickname: "Settings",
                    path: "settings.json",
                    out Settings
                )
                .Run(args, new RunPreferences()
                {
                    ActionsForEmptyArgs = new RunDefaultPatcher()
                    {
                        IdentifyingModKey = "YourPatcher.esp",
                        TargetRelease = GameRelease.SkyrimSE,
                    }
                });
        }

        private static readonly Dictionary<FormKey, HashSet<FormKey>> HalfCostPerkIDToLevelledListIDs = new()
        {
            { Skyrim.Perk.AlterationApprentice25, new() { Skyrim.LeveledItem.LItemStaffAlteration25 } },
            { Skyrim.Perk.AlterationExpert75, new() { Skyrim.LeveledItem.LItemStaffAlteration75 } },
            { Skyrim.Perk.ConjurationNovice00, new() { Skyrim.LeveledItem.LItemStaffConjuration00, Skyrim.LeveledItem.LItemStaffConjuration00NPC } },
            { Skyrim.Perk.ConjurationApprentice25, new() { Skyrim.LeveledItem.LItemStaffConjuration25, Skyrim.LeveledItem.LItemStaffConjuration25NPC } },
            { Skyrim.Perk.ConjurationAdept50, new() { Skyrim.LeveledItem.LItemStaffConjuration50, Skyrim.LeveledItem.LItemStaffConjuration50NPC } },
            { Skyrim.Perk.ConjurationExpert75, new() { Skyrim.LeveledItem.LItemStaffConjuration75, Skyrim.LeveledItem.LItemStaffConjuration75NPC } },
            { Skyrim.Perk.DestructionNovice00, new() { Skyrim.LeveledItem.LItemStaffDestruction00 } },
            { Skyrim.Perk.DestructionApprentice25, new() { Skyrim.LeveledItem.LItemStaffDestruction25, Skyrim.LeveledItem.LItemStaffDestruction25NPC50 } },
            { Skyrim.Perk.DestructionAdept50, new() { Skyrim.LeveledItem.LItemStaffDestruction50, Skyrim.LeveledItem.LItemStaffDestruction50NPC50 } },
            { Skyrim.Perk.DestructionExpert75, new() { Skyrim.LeveledItem.LItemStaffDestruction75 } },
            { Skyrim.Perk.IllusionNovice00, new() { Skyrim.LeveledItem.LItemStaffIllusion00 } },
            { Skyrim.Perk.IllusionApprentice25, new() { Skyrim.LeveledItem.LItemStaffIllusion25 } },
            { Skyrim.Perk.IllusionAdept50, new() { Skyrim.LeveledItem.LItemStaffIllusion50 } },
            { Skyrim.Perk.IllusionExpert75, new() { Skyrim.LeveledItem.LItemStaffIllusion75 } },
            { Skyrim.Perk.RestorationApprentice25, new() { Skyrim.LeveledItem.LItemStaffRestoration25 } },
            { Skyrim.Perk.RestorationAdept50, new() { Skyrim.LeveledItem.LItemStaffRestoration50 } },
            { Skyrim.Perk.RestorationExpert75, new() { Skyrim.LeveledItem.LItemStaffRestoration75 } },
        };

        private static readonly Dictionary<FormKey, (MagicSchool school, MagicLevel level)> HalfCostPerkIDToMagicSchoolAndLevel = new()
        {
            { Skyrim.Perk.AlterationNovice00, (MagicSchool.Alteration, MagicLevel.Novice) },
            { Skyrim.Perk.AlterationApprentice25, (MagicSchool.Alteration, MagicLevel.Apprentice) },
            { Skyrim.Perk.AlterationAdept50, (MagicSchool.Alteration, MagicLevel.Adept) },
            { Skyrim.Perk.AlterationExpert75, (MagicSchool.Alteration, MagicLevel.Expert) },
            { Skyrim.Perk.ConjurationNovice00, (MagicSchool.Conjuration, MagicLevel.Novice) },
            { Skyrim.Perk.ConjurationApprentice25, (MagicSchool.Conjuration, MagicLevel.Apprentice) },
            { Skyrim.Perk.ConjurationAdept50, (MagicSchool.Conjuration, MagicLevel.Adept) },
            { Skyrim.Perk.ConjurationExpert75, (MagicSchool.Conjuration, MagicLevel.Expert) },
            { Skyrim.Perk.DestructionNovice00, (MagicSchool.Destruction, MagicLevel.Novice) },
            { Skyrim.Perk.DestructionApprentice25, (MagicSchool.Destruction, MagicLevel.Apprentice) },
            { Skyrim.Perk.DestructionAdept50, (MagicSchool.Destruction, MagicLevel.Adept) },
            { Skyrim.Perk.DestructionExpert75, (MagicSchool.Destruction, MagicLevel.Expert) },
            { Skyrim.Perk.IllusionNovice00, (MagicSchool.Illusion, MagicLevel.Novice) },
            { Skyrim.Perk.IllusionApprentice25, (MagicSchool.Illusion, MagicLevel.Apprentice) },
            { Skyrim.Perk.IllusionAdept50, (MagicSchool.Illusion, MagicLevel.Adept) },
            { Skyrim.Perk.IllusionExpert75, (MagicSchool.Illusion, MagicLevel.Expert) },
            { Skyrim.Perk.RestorationNovice00, (MagicSchool.Restoration, MagicLevel.Novice) },
            { Skyrim.Perk.RestorationApprentice25, (MagicSchool.Restoration, MagicLevel.Apprentice) },
            { Skyrim.Perk.RestorationAdept50, (MagicSchool.Restoration, MagicLevel.Adept) },
            { Skyrim.Perk.RestorationExpert75, (MagicSchool.Restoration, MagicLevel.Expert) },
        };

        private static readonly Dictionary<MagicLevel, (int heartStoneCount, ushort enchantmentAmount)> MagicLevelToStaffData = new()
        {
            { MagicLevel.Novice, (1, 500) },
            { MagicLevel.Apprentice, (2, 1000) },
            { MagicLevel.Adept, (3, 2000) },
            { MagicLevel.Expert, (4, 3000) },
            { MagicLevel.Master, (5, 4000) },
        };

        private static readonly HashSet<CastType> AllowedCastTypes = new()
        {
            CastType.Concentration,
            CastType.FireAndForget
        };

        private static readonly HashSet<FormKey> AllowedEquipmentTypes = new()
        {
            Skyrim.EquipType.EitherHand,
            Skyrim.EquipType.LeftHand,
            Skyrim.EquipType.RightHand
        };

        private static readonly HashSet<ConditionData.Function> conditionFunctionsAlwaysFalseUsingAStaff = new()
        {
            ConditionData.Function.EffectWasDualCast,
            ConditionData.Function.IsDualCasting,
        };

        private static readonly HashSet<ConditionData.Function> playerOnlyConditionFunctions = new()
        {
            ConditionData.Function.IsPCAMurderer,
            ConditionData.Function.GetPCExpelled,
            ConditionData.Function.GetPCFactionMurder,
            ConditionData.Function.GetPCEnemyofFaction,
            ConditionData.Function.GetPCFactionAttack,
            ConditionData.Function.GetVATSMode,
            ConditionData.Function.GetPCMiscStat,
        };

        private static readonly Dictionary<ConditionData.Function, ConditionData.Function> playerSpecificToCasterConditionFunctions = new()
        {
            { ConditionData.Function.GetPCIsClass, ConditionData.Function.GetIsClass },
            { ConditionData.Function.GetPCIsRace, ConditionData.Function.GetIsRace },
            { ConditionData.Function.GetPCIsSex, ConditionData.Function.GetIsSex },
            { ConditionData.Function.GetPCInFaction, ConditionData.Function.GetInFaction },
            { ConditionData.Function.SameFactionAsPC, ConditionData.Function.SameFaction },
            { ConditionData.Function.SameRaceAsPC, ConditionData.Function.SameRace },
            { ConditionData.Function.SameSexAsPC, ConditionData.Function.SameSex },
        };

        private static readonly Dictionary<FormKey, MagicSchool> UnenchantedStaffIDByMagicSchool = new()
        {
            { Skyrim.Weapon.StaffTemplateAlteration, MagicSchool.Alteration },
            { Skyrim.Weapon.StaffTemplateConjuration, MagicSchool.Conjuration },
            { Skyrim.Weapon.StaffTemplateDestruction, MagicSchool.Destruction },
            { Skyrim.Weapon.StaffTemplateIIllusion, MagicSchool.Illusion },
            { Skyrim.Weapon.StaffTemplateRestoration, MagicSchool.Restoration },
        };

        private static FormLinkNullable<T> NewFormLinkNullable<T>(T majorRecord) where T : class, IMajorRecordGetter
        {
            return new FormLinkNullable<T>(majorRecord.FormKey);
        }

        private static FormLink<T> NewFormLink<T>(FormLinkNullable<T> majorRecordLink) where T : class, IMajorRecordCommonGetter
        {
            return new FormLink<T>(majorRecordLink.FormKey);
        }

        private static FormLink<T> NewFormLink<T>(T majorRecord) where T : class, IMajorRecordGetter
        {
            return new FormLink<T>(majorRecord.FormKey);
        }

        public static void RunPatch(IPatcherState<ISkyrimMod, ISkyrimModGetter> state)
        {
            var modifiedQAStaffContainer = new Lazy<IContainer>(() => state.PatchMod.Containers.GetOrAddAsOverride(state.LinkCache.Resolve<IContainerGetter>(Skyrim.Container.QAStaffContainer)));

            ImmutableDictionary<string, IObjectEffectGetter> staffEnchantmentsByEditorID;
            ImmutableDictionary<FormLink<IMagicEffectGetter>, ImmutableHashSet<IObjectEffectGetter>> staffEnchantmentsByMagicEffect;

            {
                var staffEnchantmentsByEditorIDBuilder = ImmutableDictionary.CreateBuilder<string, IObjectEffectGetter>();
                var staffEnchantmentsByMagicEffectTemp = new Dictionary<FormLink<IMagicEffectGetter>, ImmutableHashSet<IObjectEffectGetter>.Builder>();

                foreach (var staffEnchantment in state.LoadOrder.PriorityOrder.ObjectEffect().WinningOverrides())
                {
                    if (staffEnchantment.EnchantType != ObjectEffect.EnchantTypeEnum.StaffEnchantment) continue;
                    if (staffEnchantment.EditorID is null) continue;
                    foreach (var magicEffect in staffEnchantment.Effects)
                    {
                        var baseEffect = magicEffect.BaseEffect;
                        if (baseEffect.IsNull) continue;
                        Autovivify(staffEnchantmentsByMagicEffectTemp, NewFormLink(baseEffect)).Add(staffEnchantment);
                    }
                    staffEnchantmentsByEditorIDBuilder[staffEnchantment.EditorID] = staffEnchantment;
                }

                var staffEnchantmentsByMagicEffectBuilder = ImmutableDictionary.CreateBuilder<FormLink<IMagicEffectGetter>, ImmutableHashSet<IObjectEffectGetter>>();
                foreach (var item in staffEnchantmentsByMagicEffectTemp)
                {
                    staffEnchantmentsByMagicEffectBuilder[item.Key] = item.Value.ToImmutable();
                }

                staffEnchantmentsByEditorID = staffEnchantmentsByEditorIDBuilder.ToImmutable();
                staffEnchantmentsByMagicEffect = staffEnchantmentsByMagicEffectBuilder.ToImmutable();
            }

            ImmutableHashSet<FormLink<IWeaponGetter>> staves;
            ImmutableDictionary<string, IWeaponGetter> stavesByEditorID;
            ImmutableDictionary<MagicSchool, IWeaponGetter> unenchantedStavesByMagicSchool;
            ImmutableDictionary<FormLink<IEffectRecordGetter>, ImmutableHashSet<IWeaponGetter>> enchantedStavesByEnchantment;

            {
                var stavesBuilder = ImmutableHashSet.CreateBuilder<FormLink<IWeaponGetter>>();
                var stavesByEditorIDBuilder = ImmutableDictionary.CreateBuilder<string, IWeaponGetter>();
                var unenchantedStavesByMagicSchoolBuilder = ImmutableDictionary.CreateBuilder<MagicSchool, IWeaponGetter>();
                var enchantedStavesByEnchantmentTemp = new Dictionary<FormLink<IEffectRecordGetter>, ImmutableHashSet<IWeaponGetter>.Builder>();

                foreach (var staff in state.LoadOrder.PriorityOrder.Weapon().WinningOverrides())
                {
                    if (staff.Keywords?.Contains(Skyrim.Keyword.WeapTypeStaff) != true) continue;
                    if (staff.EditorID is null) continue;
                    if (UnenchantedStaffIDByMagicSchool.TryGetValue(staff.FormKey, out var magicSchool))
                        unenchantedStavesByMagicSchoolBuilder.Add(magicSchool, staff);
                    if (!staff.ObjectEffect.IsNull)
                    {
                        if (staff.Template.IsNull) continue;
                        stavesBuilder.Add(staff.AsLink());
                        stavesByEditorIDBuilder[staff.EditorID] = staff;
                        Autovivify(enchantedStavesByEnchantmentTemp, NewFormLink(staff.ObjectEffect)).Add(staff);
                    }
                }

                var enchantedStavesByEnchantmentBuilder = ImmutableDictionary.CreateBuilder<FormLink<IEffectRecordGetter>, ImmutableHashSet<IWeaponGetter>>();
                foreach (var item in enchantedStavesByEnchantmentTemp)
                {
                    enchantedStavesByEnchantmentBuilder[item.Key] = item.Value.ToImmutable();
                }

                staves = stavesBuilder.ToImmutable();
                stavesByEditorID = stavesByEditorIDBuilder.ToImmutable();
                unenchantedStavesByMagicSchool = unenchantedStavesByMagicSchoolBuilder.ToImmutable();
                enchantedStavesByEnchantment = enchantedStavesByEnchantmentBuilder.ToImmutable();
            }

            ImmutableDictionary<FormLink<IWeaponGetter>, IConstructibleObjectGetter> recipesByCreatedStaff;

            {
                var recipesByCreatedStaffBuilder = ImmutableDictionary.CreateBuilder<FormLink<IWeaponGetter>, IConstructibleObjectGetter>();

                foreach (var recipe in state.LoadOrder.PriorityOrder.ConstructibleObject().WinningOverrides())
                {
                    if (recipe.CreatedObjectCount.HasValue)
                        if (!(recipe.CreatedObjectCount.Value == 1)) continue;
                    if (recipe.CreatedObject.IsNull) continue;
                    if (!staves.Contains(recipe.CreatedObject.FormKey)) continue;
                    recipesByCreatedStaffBuilder[new FormLink<IWeaponGetter>(recipe.CreatedObject.FormKey)] = recipe;
                }

                recipesByCreatedStaff = recipesByCreatedStaffBuilder.ToImmutable();
            }

            ImmutableDictionary<FormKey, ILeveledItemGetter> leveledListsByFormKey;
            ImmutableDictionary<string, ILeveledItemGetter> leveledListsByEditorID;

            {
                var leveledListsByFormKeyBuilder = ImmutableDictionary.CreateBuilder<FormKey, ILeveledItemGetter>();
                var leveledListsByEditorIDBuilder = ImmutableDictionary.CreateBuilder<string, ILeveledItemGetter>();

                foreach (var leveledList in state.LoadOrder.PriorityOrder.LeveledItem().WinningOverrides())
                {
                    if (leveledList.EditorID is null) continue;
                    leveledListsByFormKeyBuilder[leveledList.FormKey] = leveledList;
                    leveledListsByEditorIDBuilder[leveledList.EditorID] = leveledList;
                }

                leveledListsByFormKey = leveledListsByFormKeyBuilder.ToImmutable();
                leveledListsByEditorID = leveledListsByEditorIDBuilder.ToImmutable();
            }

            Func<IWeaponGetter, int, ExtendedList<ContainerEntry>> makeNewRecipeIngredients = (unenchantedStaff, heartStoneCount) => new()
            {
                new()
                {
                    Item = new()
                    {
                        Item = unenchantedStaff.AsLink<IItemGetter>(),
                        Count = 1
                    }
                },
                new()
                {
                    Item = new()
                    {
                        Item = Dragonborn.MiscItem.DLC2HeartStone,
                        Count = heartStoneCount
                    }
                }
            };

            makeNewRecipeIngredients = Memoize(makeNewRecipeIngredients);

            var stavesData = new List<StaffData>();

            foreach (var book in state.LoadOrder.PriorityOrder.Book().WinningOverrides())
            {
                if (Settings.Value.SpellBooksNotToCreateStavesFor.Contains(book)) continue;
                if (book.Teaches is not IBookSpellGetter spellBook) continue;

                if (!spellBook.Spell.TryResolve(state.LinkCache, out var spell)) continue;
                if (Settings.Value.SpellsNotToCreateStavesFor.Contains(spell)) continue;

                if (spell.Name is null) continue;
                if (spell.Name.String is null) continue;
                var spellName = spell.Name.String;
                if (spell.EditorID is null) continue;
                var spellEditorID = spell.EditorID;
                if (spell.Type != SpellType.Spell) continue;
                if (spell.TargetType == TargetType.Self) continue;
                if (!AllowedCastTypes.Contains(spell.CastType)) continue;
                if (!AllowedEquipmentTypes.Contains(spell.EquipmentType.FormKey)) continue;

                var halfCostPerkID = spell.HalfCostPerk;

                if (!HalfCostPerkIDToMagicSchoolAndLevel.TryGetValue(halfCostPerkID.FormKey, out var magicSchoolAndLevel)) continue;

                var (magicSchool, magicLevel) = magicSchoolAndLevel;

                if (!MagicLevelToStaffData.TryGetValue(magicLevel, out var staffData)) continue;

                if (!unenchantedStavesByMagicSchool.TryGetValue(magicSchool, out var unenchantedStaff)) continue;

                stavesData.Add(new StaffData(book, spell, spellName, spellEditorID, magicSchool, magicLevel, unenchantedStaff, staffData.heartStoneCount, staffData.enchantmentAmount));
            }

            var claimedEnchantments = new HashSet<IObjectEffectGetter>();

            foreach (var staffData in stavesData)
            {
                staffData.EnchantmentEditorID = "StaffEnch" + staffData.SpellEditorID;

                if (staffEnchantmentsByEditorID.TryGetValue(staffData.EnchantmentEditorID, out staffData.Enchantment))
                    claimedEnchantments.Add(staffData.Enchantment);
            }

            IEnumerable<Effect> spellToStaffEffects(StaffData staffData)
            {
                // TODO filter and/or modify conditions.
                return staffData.Spell.Effects.Where(x => !x.BaseEffect.IsNull).Select(x => x.DeepCopy());
            }

            foreach (var staffData in stavesData)
            {
                if (staffData.Enchantment is not null) continue;

                var candidateEnchantments = new Dictionary<IObjectEffectGetter, int>();

                foreach (var magicEffect in staffData.Spell.Effects)
                {
                    var baseEffect = magicEffect.BaseEffect;
                    if (baseEffect.IsNull) continue;
                    if (staffEnchantmentsByMagicEffect.TryGetValue(NewFormLink(baseEffect), out var candidateEnchantments1))
                    {
                        foreach (var candidateEnchantment in candidateEnchantments1)
                        {
                            if (claimedEnchantments.Contains(candidateEnchantment)) continue;
                            candidateEnchantments.TryGetValue(candidateEnchantment, out var count);
                            candidateEnchantments[candidateEnchantment] = count + 1;
                        }
                    }
                }

                foreach (var candidateEnchantment in candidateEnchantments.OrderBy(x => x.Value))
                {
                    // TODO how do we pick the right one?
                    staffData.Enchantment = candidateEnchantment.Key;
                    claimedEnchantments.Add(candidateEnchantment.Key);
                    break;
                }

                if (staffData.Enchantment is not null)
                {
                    if (candidateEnchantments.Count > 1)
                    {
                        Console.WriteLine($"For the spell {PrettyPrintMajorRecord(staffData.Spell)},");
                        Console.WriteLine($"selected {PrettyPrintMajorRecord(staffData.Enchantment)} from the other possibilities:");
                        foreach (var (candidateEnchanement, count) in candidateEnchantments)
                            if (candidateEnchanement != staffData.Enchantment)
                                Console.WriteLine(PrettyPrintMajorRecord(candidateEnchanement));
                        Console.WriteLine();
                    }
                    continue;
                }

                var newEnchantment = state.PatchMod.ObjectEffects.AddNew(staffData.EnchantmentEditorID);
                newEnchantment.Name = staffData.SpellName;
                newEnchantment.CastType = staffData.Spell.CastType;
                newEnchantment.TargetType = staffData.Spell.TargetType;
                newEnchantment.EnchantType = ObjectEffect.EnchantTypeEnum.StaffEnchantment;
                newEnchantment.Effects.AddRange(spellToStaffEffects(staffData));

                staffData.EnchantmentExisted = false;

                staffData.Enchantment = newEnchantment;
            }

            if (Settings.Value.CopySpellEffectsToExistingStaffEnchantments)
                foreach (var staffData in stavesData)
                {
                    if (staffData.Enchantment is null) throw new NullReferenceException(); // Can't happen.
                    if (!staffData.EnchantmentExisted) continue;
                    if (Settings.Value.StaffEnchantmentsNotToRefresh.Contains(staffData.Enchantment)) continue;

                    var enchantment = staffData.Enchantment;
                    var modifiedEnchantment = enchantment.DeepCopy();

                    bool modified = false;

                    if (modifiedEnchantment.Name != staffData.SpellName)
                    {
                        modifiedEnchantment.Name = staffData.SpellName;
                        modified = true;
                    }

                    if (modifiedEnchantment.CastType != staffData.Spell.CastType)
                    {
                        modifiedEnchantment.CastType = staffData.Spell.CastType;
                        modified = true;
                    }

                    if (modifiedEnchantment.TargetType != staffData.Spell.TargetType)
                    {
                        modifiedEnchantment.TargetType = staffData.Spell.TargetType;
                        modified = true;
                    }

                    var newEffects = spellToStaffEffects(staffData);

                    if (!modifiedEnchantment.Effects.Equals(newEffects))
                    {
                        modifiedEnchantment.Effects.Clear();
                        modifiedEnchantment.Effects.AddRange(newEffects);
                        modified = true;
                    }

                    if (modified)
                    {
                        state.PatchMod.ObjectEffects.Set(modifiedEnchantment);
                        staffData.Enchantment = modifiedEnchantment;
                    }
                }

            var claimedStaves = new HashSet<IWeaponGetter>();

            foreach (var staffData in stavesData)
            {
                staffData.StaffEditorID = "Staff" + staffData.SpellEditorID;

                if (stavesByEditorID.TryGetValue(staffData.StaffEditorID, out staffData.Staff))
                    claimedStaves.Add(staffData.Staff);
            }

            var newStavesByHalfCostPerk = new Dictionary<FormLink<IPerkGetter>, List<IWeapon>>();

            foreach (var staffData in stavesData)
            {
                if (staffData.Staff is not null) continue;
                if (staffData.Enchantment is null)
                    throw new NullReferenceException("Can't happen");

                if (enchantedStavesByEnchantment.TryGetValue(NewFormLink<IEffectRecordGetter>(staffData.Enchantment), out var candidateStaves))
                {
                    var unenchantedStaffLink = staffData.UnenchantedStaff.AsLink();

                    var filteredCandidates = (
                        from candidateStaff in candidateStaves
                        where !claimedStaves.Contains(candidateStaff)
                        where candidateStaff.Template == unenchantedStaffLink
                        select candidateStaff
                    ).ToList();

                    foreach (var candidateStaff in filteredCandidates)
                    {
                        if (candidateStaff.EditorID?.Equals(staffData.StaffEditorID, StringComparison.OrdinalIgnoreCase) != true) continue;
                        claimedStaves.Add(candidateStaff);
                        staffData.Staff = candidateStaff;
                        break;
                    }

                    if (staffData.Staff is null)
                        foreach (var candidateStaff in filteredCandidates)
                        {
                            // TODO add more criteria?
                            claimedStaves.Add(candidateStaff);
                            staffData.Staff = candidateStaff;
                            break;
                        }

                    if (staffData.Staff is not null && filteredCandidates.Count > 1)
                    {
                        Console.WriteLine($"For the spell {PrettyPrintMajorRecord(staffData.Spell)},");
                        Console.WriteLine($"Selected {PrettyPrintMajorRecord(staffData.Staff)} from the other possibilities:");
                        foreach (var candidateStaff in filteredCandidates)
                            if (candidateStaff != staffData.Staff)
                                Console.WriteLine(PrettyPrintMajorRecord(candidateStaff));
                        Console.WriteLine();
                    }
                }

                if (staffData.Staff is not null) { 
                    continue; 
                }

                var newStaff = state.PatchMod.Weapons.AddNew(staffData.StaffEditorID);
                staffData.StaffExisted = false;
                newStaff.DeepCopyIn(staffData.UnenchantedStaff, new Weapon.TranslationMask(true)
                {
                    EditorID = false,
                    Name = false,
                    Template = false,
                    ObjectEffect = false,
                    EnchantmentAmount = false
                });

                newStaff.Name = Settings.Value.StaffNamePrefix + staffData.SpellName + Settings.Value.StaffNameSuffix;
                newStaff.Template = NewFormLinkNullable(staffData.UnenchantedStaff);
                newStaff.ObjectEffect = NewFormLinkNullable<IEffectRecordGetter>(staffData.Enchantment);
                newStaff.EnchantmentAmount = staffData.EnchantmentAmount;
                if (Settings.Value.SetStaffPriceToSpellBookPrice)
                    (newStaff.BasicStats ??= new()).Value = staffData.Book.Value;

                (modifiedQAStaffContainer.Value.Items ??= new()).Add(new()
                {
                    Item = new()
                    {
                        Item = newStaff.AsLink<IItemGetter>(),
                        Count = 1
                    }
                });

                Autovivify(newStavesByHalfCostPerk, staffData.Spell.HalfCostPerk).Add(newStaff);

                staffData.Staff = newStaff;
            }

            foreach (var staffData in stavesData)
            {
                if (staffData.Staff is null)
                    throw new NullReferenceException("Can't happen");

                if (!staffData.StaffExisted) continue;

                if (!(Settings.Value.OverrideNamesOfExistingStaves || Settings.Value.SetStaffPriceToSpellBookPrice)) continue;

                var modifiedStaff = state.PatchMod.Weapons.GetOrAddAsOverride(staffData.Staff);

                if (Settings.Value.OverrideNamesOfExistingStaves)
                    modifiedStaff.Name = Settings.Value.StaffNamePrefix + staffData.SpellName + Settings.Value.StaffNameSuffix;
                
                if (Settings.Value.SetStaffPriceToSpellBookPrice)
                    (modifiedStaff.BasicStats ??= new()).Value = staffData.Book.Value;

                staffData.Staff = modifiedStaff;
            }

            foreach (var staffData in stavesData)
            {
                if (staffData.Staff is null)
                    throw new NullReferenceException("Can't happen");
                if (Settings.Value.StavesToNotRefreshRecipesFor.Contains(staffData.Staff)) continue;

                IConstructibleObject newRecipe;
                if (recipesByCreatedStaff.TryGetValue(staffData.Staff.FormKey, out var oldRrecipe))
                    newRecipe = state.PatchMod.ConstructibleObjects.GetOrAddAsOverride(oldRrecipe);
                else
                    newRecipe = state.PatchMod.ConstructibleObjects.AddNew("DLC2Recipe" + staffData.StaffEditorID);

                newRecipe.Items = makeNewRecipeIngredients(staffData.UnenchantedStaff, staffData.HeartStoneCount);

                newRecipe.Conditions.Clear();
                newRecipe.Conditions.Add(new ConditionFloat()
                {
                    CompareOperator = CompareOperator.EqualTo,
                    ComparisonValue = 1,
                    Data = new FunctionConditionData()
                    {
                        Function = (ushort)ConditionData.Function.HasSpell,
                        ParameterOneRecord = staffData.Spell.AsLink<ISkyrimMajorRecordGetter>(),
                        Unknown2 = 0,
                        Unknown3 = (int)Condition.RunOnType.Reference,
                        Unknown4 = 0x00000014, // PlayerRef [PLYR:000014]
                        Unknown5 = -1
                    }
                });
                newRecipe.CreatedObject = NewFormLinkNullable<IConstructibleGetter>(staffData.Staff);
                newRecipe.WorkbenchKeyword = Dragonborn.Keyword.DLC2StaffEnchanter;
                newRecipe.CreatedObjectCount = 1;
            }

            var leveledListByMagicLevel = new Dictionary<MagicLevel, ILeveledItem>();
            var modifiedLeveledListByFormKey = new Dictionary<FormKey, ILeveledItem>();

            // TODO add found staves if they're not in already in the leveled lists?
            foreach (var (halfCostPerkID, newStaves) in newStavesByHalfCostPerk)
            {
                var (magicSchool, magicLevel) = HalfCostPerkIDToMagicSchoolAndLevel[halfCostPerkID.FormKey];

                if (newStaves.Count > 1)
                    Console.WriteLine($"Adding {newStaves.Count} new {magicLevel} {magicSchool} staves to the appropriate leveled lists.");
                else
                    Console.WriteLine($"Adding {newStaves.Count} new {magicLevel} {magicSchool} staff to the appropriate leveled lists.");

                var leveledLists = new HashSet<ILeveledItemGetter>();
                var modifiedLeveledLists = new List<ILeveledItem>();

                if (HalfCostPerkIDToLevelledListIDs.TryGetValue(halfCostPerkID.FormKey, out var leveledListIDs))
                    leveledLists.UnionWith(leveledListIDs.Select(x => leveledListsByFormKey[x]));

                var magicLevelString = String.Format("{0:D2}", (int)magicLevel);

                var leveledListEditorID = $"LItemStaff{magicSchool:g}{magicLevelString}";
                if (leveledListsByEditorID.TryGetValue(leveledListEditorID, out var leveledList))
                    leveledLists.Add(leveledList);
                else
                {
                    var newLeveledList = state.PatchMod.LeveledItems.AddNew(leveledListEditorID);
                    newLeveledList.ChanceNone = 0;
                    newLeveledList.Flags = LeveledItem.Flag.CalculateForEachItemInCount | LeveledItem.Flag.CalculateFromAllLevelsLessThanOrEqualPlayer;

                    (Autovivify(leveledListByMagicLevel, magicLevel, () => state.PatchMod.LeveledItems.GetOrAddAsOverride(leveledListsByEditorID[$"LItemStaff{magicLevelString}"])).Entries ??= new()).Add(new()
                    {
                        Data = new()
                        {
                            Level = 1,
                            Reference = newLeveledList.AsLink<IItemGetter>(),
                            Count = 1,
                        }
                    });

                    modifiedLeveledLists.Add(newLeveledList);
                }

                foreach (var leveledList2 in leveledLists)
                    modifiedLeveledLists.Add(Autovivify(modifiedLeveledListByFormKey, leveledList2.FormKey, () => state.PatchMod.LeveledItems.GetOrAddAsOverride(leveledList2)));

                var leveledItems = newStaves.Select(staff => new LeveledItemEntry()
                {
                    Data = new()
                    {
                        Level = 1,
                        Reference = staff.AsLink<IItemGetter>(),
                        Count = 1,
                    }
                }).ToList();

                foreach (var leveledList3 in modifiedLeveledLists)
                    (leveledList3.Entries ??= new()).AddRange(leveledItems);
            }
        }

        private static Func<T, TResult> Memoize<T, TResult>(Func<T, TResult> func) where T : notnull
        {
            var cache = new ConcurrentDictionary<T, TResult>();
            return a => cache.GetOrAdd(a, func);
        }

        private static Func<T1, T2, TResult> Memoize<T1, T2, TResult>(Func<T1, T2, TResult> func)
        {
            var cache = new ConcurrentDictionary<(T1 a, T2 b), TResult>();
            return (a, b) => cache.GetOrAdd((a, b), (x) => func(x.a, x.b));
        }

        private static string PrettyPrintMajorRecord(IMajorRecordGetter record)
        {
            if (record is INamedGetter hasName)
                return $"{record.EditorID} \"{hasName.Name}\" {record.FormKey}";
            return $"{record.EditorID} {record.FormKey}";
        }

        private static V Autovivify<K, V>(IDictionary<K, V> dict, K key) where K : notnull where V : new() => Autovivify(dict, key, () => new());

        private static ImmutableHashSet<V>.Builder Autovivify<K, V>(IDictionary<K, ImmutableHashSet<V>.Builder> dict, K key) where K : notnull => Autovivify(dict, key, () => ImmutableHashSet.CreateBuilder<V>());

        private static V Autovivify<K, V>(IDictionary<K, V> dict, K key, Func<V> newThing) where K : notnull
        {
            if (!dict.TryGetValue(key, out var value))
                value = dict[key] = newThing();
            return value;
        }
    }
}
