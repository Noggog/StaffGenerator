using Mutagen.Bethesda;
using Mutagen.Bethesda.FormKeys.SkyrimSE;
using Mutagen.Bethesda.Skyrim;
using Mutagen.Bethesda.Synthesis;
using Noggog;
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Threading.Tasks;

namespace System.Runtime.CompilerServices
{
    class IsExternalInit {
    }
}

namespace StaffGenerator
{
    record StaffData(IBookGetter Book, ISpellGetter Spell, string SpellName, string SpellEditorID, MagicSchool MagisSchool, MagicLevel MagicLevel, IWeaponGetter UnenchantedStaff, int HeartStoneCount, ushort EnchantmentAmount)
    {
        public string? EnchantmentEditorID;
        public IObjectEffectGetter? Enchantment;

        public bool EnchantmentExisted = true;

        public string? StaffEditorID;
        public IWeaponGetter? Staff;

        public bool StaffExisted = true;
    }

    enum MagicSchool
    {
        Alteration,
        Conjuration,
        Destruction,
        Illusion,
        Restoration
    };

    enum MagicLevel
    {
        Novice = 0,
        Apprentice = 25,
        Adept = 50,
        Expert = 75,
        Master = 100
    };


    public class Program
    {
        static Lazy<Settings> Settings = null!;

        public static async Task<int> Main(string[] args)
        {
            return await SynthesisPipeline.Instance
                .AddPatch<ISkyrimMod, ISkyrimModGetter>(RunPatch)
                .SetAutogeneratedSettings(
                    nickname: "Settings",
                    path: "settings.json",
                    out Settings
                    )
                .Run(args, new RunPreferences()
                {
                    ActionsForEmptyArgs = new RunDefaultPatcher()
                    {
                        IdentifyingModKey = "YourPatcher.esp",
                        TargetRelease = GameRelease.SkyrimSE,
                    }
                });
        }

        private static readonly Dictionary<FormKey, HashSet<FormKey>> HalfCostPerkIDToLevelledListIDs = new()
        {
            { Skyrim.Perk.AlterationApprentice25, new() { Skyrim.LeveledItem.LItemStaffAlteration25 } },
            { Skyrim.Perk.AlterationExpert75, new() { Skyrim.LeveledItem.LItemStaffAlteration75 } },
            { Skyrim.Perk.ConjurationNovice00, new() { Skyrim.LeveledItem.LItemStaffConjuration00, Skyrim.LeveledItem.LItemStaffConjuration00NPC } },
            { Skyrim.Perk.ConjurationApprentice25, new() { Skyrim.LeveledItem.LItemStaffConjuration25, Skyrim.LeveledItem.LItemStaffConjuration25NPC } },
            { Skyrim.Perk.ConjurationAdept50, new() { Skyrim.LeveledItem.LItemStaffConjuration50, Skyrim.LeveledItem.LItemStaffConjuration50NPC } },
            { Skyrim.Perk.ConjurationExpert75, new() { Skyrim.LeveledItem.LItemStaffConjuration75, Skyrim.LeveledItem.LItemStaffConjuration75NPC } },
            { Skyrim.Perk.DestructionNovice00, new() { Skyrim.LeveledItem.LItemStaffDestruction00 } },
            { Skyrim.Perk.DestructionApprentice25, new() { Skyrim.LeveledItem.LItemStaffDestruction25, Skyrim.LeveledItem.LItemStaffDestruction25NPC50 } },
            { Skyrim.Perk.DestructionAdept50, new() { Skyrim.LeveledItem.LItemStaffDestruction50, Skyrim.LeveledItem.LItemStaffDestruction50NPC50 } },
            { Skyrim.Perk.DestructionExpert75, new() { Skyrim.LeveledItem.LItemStaffDestruction75 } },
            { Skyrim.Perk.IllusionNovice00, new() { Skyrim.LeveledItem.LItemStaffIllusion00 } },
            { Skyrim.Perk.IllusionApprentice25, new() { Skyrim.LeveledItem.LItemStaffIllusion25 } },
            { Skyrim.Perk.IllusionAdept50, new() { Skyrim.LeveledItem.LItemStaffIllusion50 } },
            { Skyrim.Perk.IllusionExpert75, new() { Skyrim.LeveledItem.LItemStaffIllusion75 } },
            { Skyrim.Perk.RestorationApprentice25, new() { Skyrim.LeveledItem.LItemStaffRestoration25 } },
            { Skyrim.Perk.RestorationAdept50, new() { Skyrim.LeveledItem.LItemStaffRestoration50 } },
            { Skyrim.Perk.RestorationExpert75, new() { Skyrim.LeveledItem.LItemStaffRestoration75 } },
        };

        private static readonly Dictionary<FormKey, (MagicSchool school, MagicLevel level)> HalfCostPerkIDToMagicSchoolAndLevel = new()
        {
            { Skyrim.Perk.AlterationNovice00, (MagicSchool.Alteration, MagicLevel.Novice) },
            { Skyrim.Perk.AlterationApprentice25, (MagicSchool.Alteration, MagicLevel.Apprentice) },
            { Skyrim.Perk.AlterationAdept50, (MagicSchool.Alteration, MagicLevel.Adept) },
            { Skyrim.Perk.AlterationExpert75, (MagicSchool.Alteration, MagicLevel.Expert) },
            { Skyrim.Perk.ConjurationNovice00, (MagicSchool.Conjuration, MagicLevel.Novice) },
            { Skyrim.Perk.ConjurationApprentice25, (MagicSchool.Conjuration, MagicLevel.Apprentice) },
            { Skyrim.Perk.ConjurationAdept50, (MagicSchool.Conjuration, MagicLevel.Adept) },
            { Skyrim.Perk.ConjurationExpert75, (MagicSchool.Conjuration, MagicLevel.Expert) },
            { Skyrim.Perk.DestructionNovice00, (MagicSchool.Destruction, MagicLevel.Novice) },
            { Skyrim.Perk.DestructionApprentice25, (MagicSchool.Destruction, MagicLevel.Apprentice) },
            { Skyrim.Perk.DestructionAdept50, (MagicSchool.Destruction, MagicLevel.Adept) },
            { Skyrim.Perk.DestructionExpert75, (MagicSchool.Destruction, MagicLevel.Expert) },
            { Skyrim.Perk.IllusionNovice00, (MagicSchool.Illusion, MagicLevel.Novice) },
            { Skyrim.Perk.IllusionApprentice25, (MagicSchool.Illusion, MagicLevel.Apprentice) },
            { Skyrim.Perk.IllusionAdept50, (MagicSchool.Illusion, MagicLevel.Adept) },
            { Skyrim.Perk.IllusionExpert75, (MagicSchool.Illusion, MagicLevel.Expert) },
            { Skyrim.Perk.RestorationNovice00, (MagicSchool.Restoration, MagicLevel.Novice) },
            { Skyrim.Perk.RestorationApprentice25, (MagicSchool.Restoration, MagicLevel.Apprentice) },
            { Skyrim.Perk.RestorationAdept50, (MagicSchool.Restoration, MagicLevel.Adept) },
            { Skyrim.Perk.RestorationExpert75, (MagicSchool.Restoration, MagicLevel.Expert) },
        };

        private static readonly Dictionary<MagicLevel, (int heartStoneCount, ushort enchantmentAmount)> MagicLevelToStaffData = new()
        {
            { MagicLevel.Novice, (1, 500) },
            { MagicLevel.Apprentice, (2, 1000) },
            { MagicLevel.Adept, (3, 2000) },
            { MagicLevel.Expert, (4, 3000) },
            { MagicLevel.Master, (5, 4000) },
        };

        private static readonly HashSet<CastType> AllowedCastTypes = new()
        {
            CastType.Concentration,
            CastType.FireAndForget
        };

        private static readonly HashSet<FormKey> AllowedEquipmentTypes = new()
        {
            Skyrim.EquipType.EitherHand,
            Skyrim.EquipType.LeftHand,
            Skyrim.EquipType.RightHand
        };

        private static readonly HashSet<ConditionData.Function> conditionFunctionsAlwaysFalseUsingAStaff = new()
        {
            ConditionData.Function.EffectWasDualCast,
            ConditionData.Function.IsDualCasting,
        };

        private static readonly HashSet<ConditionData.Function> playerOnlyConditionFunctions = new()
        {
            ConditionData.Function.IsPCAMurderer,
            ConditionData.Function.GetPCExpelled,
            ConditionData.Function.GetPCFactionMurder,
            ConditionData.Function.GetPCEnemyofFaction,
            ConditionData.Function.GetPCFactionAttack,
            ConditionData.Function.GetVATSMode,
            ConditionData.Function.GetPCMiscStat,
        };

        private static readonly Dictionary<ConditionData.Function, ConditionData.Function> playerSpecificToCasterConditionFunctions = new()
        {
            { ConditionData.Function.GetPCIsClass, ConditionData.Function.GetIsClass },
            { ConditionData.Function.GetPCIsRace, ConditionData.Function.GetIsRace },
            { ConditionData.Function.GetPCIsSex, ConditionData.Function.GetIsSex },
            { ConditionData.Function.GetPCInFaction, ConditionData.Function.GetInFaction },
            { ConditionData.Function.SameFactionAsPC, ConditionData.Function.SameFaction },
            { ConditionData.Function.SameRaceAsPC, ConditionData.Function.SameRace },
            { ConditionData.Function.SameSexAsPC, ConditionData.Function.SameSex },
        };

        private static readonly Dictionary<FormKey, MagicSchool> UnenchantedStaffIDByMagicSchool = new()
        {
            { Skyrim.Weapon.StaffTemplateAlteration, MagicSchool.Alteration },
            { Skyrim.Weapon.StaffTemplateConjuration, MagicSchool.Conjuration },
            { Skyrim.Weapon.StaffTemplateDestruction, MagicSchool.Destruction },
            { Skyrim.Weapon.StaffTemplateIIllusion, MagicSchool.Illusion },
            { Skyrim.Weapon.StaffTemplateRestoration, MagicSchool.Restoration },
        };

        private static FormLinkNullable<T> NewFormLinkNullable<T>(T majorRecord) where T : class, IMajorRecordGetter
        {
            return new FormLinkNullable<T>(majorRecord.FormKey);
        }

        private static FormLink<T> NewFormLink<T>(FormLinkNullable<T> majorRecordLink) where T : class, IMajorRecordCommonGetter
        {
            return new FormLink<T>(majorRecordLink.FormKey);
        }

        private static FormLink<T> NewFormLink<T>(T majorRecord) where T : class, IMajorRecordGetter
        {
            return new FormLink<T>(majorRecord.FormKey);
        }

        public static void RunPatch(IPatcherState<ISkyrimMod, ISkyrimModGetter> state)
        {
            var modifiedQAStaffContainer = new Lazy<IContainer>(() => state.PatchMod.Containers.GetOrAddAsOverride(state.LinkCache.Resolve<IContainerGetter>(Skyrim.Container.QAStaffContainer)));

            ImmutableDictionary<string, IObjectEffectGetter> staffEnchantmentsByEditorID;
            ImmutableDictionary<FormLink<IMagicEffectGetter>, ImmutableHashSet<IObjectEffectGetter>> staffEnchantmentsByMagicEffect;

            {
                var staffEnchantmentsByEditorIDBuilder = ImmutableDictionary.CreateBuilder<string, IObjectEffectGetter>();
                var staffEnchantmentsByMagicEffectTemp = new Dictionary<FormLink<IMagicEffectGetter>, ImmutableHashSet<IObjectEffectGetter>.Builder>();

                foreach (var staffEnchantment in state.LoadOrder.PriorityOrder.ObjectEffect().WinningOverrides())
                {
                    if (staffEnchantment.EnchantType != ObjectEffect.EnchantTypeEnum.StaffEnchantment) continue;
                    if (staffEnchantment.EditorID is null) continue;
                    foreach (var magicEffect in staffEnchantment.Effects)
                    {
                        var baseEffect = magicEffect.BaseEffect;
                        if (baseEffect.IsNull) continue;
                        Autovivify(staffEnchantmentsByMagicEffectTemp, NewFormLink(baseEffect)).Add(staffEnchantment);
                    }
                    staffEnchantmentsByEditorIDBuilder.Add(staffEnchantment.EditorID, staffEnchantment);
                }

                var staffEnchantmentsByMagicEffectBuilder = ImmutableDictionary.CreateBuilder<FormLink<IMagicEffectGetter>, ImmutableHashSet<IObjectEffectGetter>>();
                foreach (var item in staffEnchantmentsByMagicEffectTemp)
                {
                    staffEnchantmentsByMagicEffectBuilder.Add(item.Key, item.Value.ToImmutable());
                }

                staffEnchantmentsByEditorID = staffEnchantmentsByEditorIDBuilder.ToImmutable();
                staffEnchantmentsByMagicEffect = staffEnchantmentsByMagicEffectBuilder.ToImmutable();
            }

            ImmutableHashSet<FormLink<IWeaponGetter>> staves;
            ImmutableDictionary<string, IWeaponGetter> stavesByEditorID;
            ImmutableDictionary<MagicSchool, IWeaponGetter> unenchantedStavesByMagicSchool;
            ImmutableDictionary<FormLink<IEffectRecordGetter>, ImmutableHashSet<IWeaponGetter>> enchantedStavesByEnchantment;

            {
                var stavesBuilder = ImmutableHashSet.CreateBuilder<FormLink<IWeaponGetter>>();
                var stavesByEditorIDBuilder = ImmutableDictionary.CreateBuilder<string, IWeaponGetter>();
                var unenchantedStavesByMagicSchoolBuilder = ImmutableDictionary.CreateBuilder<MagicSchool, IWeaponGetter>();
                var enchantedStavesByEnchantmentTemp = new Dictionary<FormLink<IEffectRecordGetter>, ImmutableHashSet<IWeaponGetter>.Builder>();

                foreach (var staff in state.LoadOrder.PriorityOrder.Weapon().WinningOverrides())
                {
                    if (staff.Keywords?.Contains(Skyrim.Keyword.WeapTypeStaff) != true) continue;
                    if (staff.EditorID is null) continue;
                    if (UnenchantedStaffIDByMagicSchool.TryGetValue(staff.FormKey, out var magicSchool))
                        unenchantedStavesByMagicSchoolBuilder.Add(magicSchool, staff);
                    if (!staff.ObjectEffect.IsNull)
                    {
                        if (staff.Template.IsNull) continue;
                        stavesBuilder.Add(staff.AsLink());
                        stavesByEditorIDBuilder.Add(staff.EditorID, staff);
                        Autovivify(enchantedStavesByEnchantmentTemp, NewFormLink(staff.ObjectEffect)).Add(staff);
                    }
                }

                var enchantedStavesByEnchantmentBuilder = ImmutableDictionary.CreateBuilder<FormLink<IEffectRecordGetter>, ImmutableHashSet<IWeaponGetter>>();
                foreach (var item in enchantedStavesByEnchantmentTemp)
                {
                    enchantedStavesByEnchantmentBuilder.Add(item.Key, item.Value.ToImmutable());
                }

                staves = stavesBuilder.ToImmutable();
                stavesByEditorID = stavesByEditorIDBuilder.ToImmutable();
                unenchantedStavesByMagicSchool = unenchantedStavesByMagicSchoolBuilder.ToImmutable();
                enchantedStavesByEnchantment = enchantedStavesByEnchantmentBuilder.ToImmutable();
            }

            ImmutableDictionary<FormLink<IWeaponGetter>, IConstructibleObjectGetter> recipesByCreatedStaff;

            {
                var recipesByCreatedStaffBuilder = ImmutableDictionary.CreateBuilder<FormLink<IWeaponGetter>, IConstructibleObjectGetter>();

                foreach (var recipe in state.LoadOrder.PriorityOrder.ConstructibleObject().WinningOverrides())
                {
                    if (recipe.CreatedObjectCount.HasValue)
                        if (!(recipe.CreatedObjectCount.Value == 1)) continue;
                    if (recipe.CreatedObject.IsNull) continue;
                    if (!staves.Contains(recipe.CreatedObject.FormKey)) continue;
                    recipesByCreatedStaffBuilder.Add(new FormLink<IWeaponGetter>(recipe.CreatedObject.FormKey), recipe);
                }

                recipesByCreatedStaff = recipesByCreatedStaffBuilder.ToImmutable();
            }

            ImmutableDictionary<FormKey, ILeveledItemGetter> leveledListsByFormKey;
            ImmutableDictionary<string, ILeveledItemGetter> leveledListsByEditorID;

            {
                var leveledListsByFormKeyBuilder = ImmutableDictionary.CreateBuilder<FormKey, ILeveledItemGetter>();
                var leveledListsByEditorIDBuilder = ImmutableDictionary.CreateBuilder<string, ILeveledItemGetter>();

                foreach (var leveledList in state.LoadOrder.PriorityOrder.LeveledItem().WinningOverrides())
                {
                    if (leveledList.EditorID is null) continue;
                    leveledListsByFormKeyBuilder.Add(leveledList.FormKey, leveledList);
                    leveledListsByEditorIDBuilder.Add(leveledList.EditorID, leveledList);
                }

                leveledListsByFormKey = leveledListsByFormKeyBuilder.ToImmutable();
                leveledListsByEditorID = leveledListsByEditorIDBuilder.ToImmutable();
            }

            Func<IWeaponGetter, int, ExtendedList<ContainerEntry>> makeNewRecipeIngredients = (unenchantedStaff, heartStoneCount) => new()
            {
                new()
                {
                    Item = new()
                    {
                        Item = unenchantedStaff.AsLink<IItemGetter>(),
                        Count = 1
                    }
                },
                new()
                {
                    Item = new()
                    {
                        Item = Dragonborn.MiscItem.DLC2HeartStone,
                        Count = heartStoneCount
                    }
                }
            };

            makeNewRecipeIngredients = Memoize(makeNewRecipeIngredients);

            var stavesData = new List<StaffData>();

            foreach (var book in state.LoadOrder.PriorityOrder.Book().WinningOverrides())
            {
                if (Settings.Value.SpellBooksNotToCreateStavesFor.Contains(book)) continue;
                if (book.Teaches is not IBookSpellGetter spellBook) continue;

                if (!spellBook.Spell.TryResolve(state.LinkCache, out var spell)) continue;
                if (Settings.Value.SpellsNotToCreateStavesFor.Contains(spell)) continue;

                if (spell.Name is null) continue;
                if (spell.Name.String is null) continue;
                var spellName = spell.Name.String;
                if (spell.EditorID is null) continue;
                var spellEditorID = spell.EditorID;
                if (spell.Type != SpellType.Spell) continue;
                if (spell.TargetType == TargetType.Self) continue;
                if (!AllowedCastTypes.Contains(spell.CastType)) continue;
                if (!AllowedEquipmentTypes.Contains(spell.EquipmentType.FormKey)) continue;

                var halfCostPerkID = spell.HalfCostPerk;

                if (!HalfCostPerkIDToMagicSchoolAndLevel.TryGetValue(halfCostPerkID.FormKey, out var magicSchoolAndLevel)) continue;

                var (magicSchool, magicLevel) = magicSchoolAndLevel;

                if (!MagicLevelToStaffData.TryGetValue(magicLevel, out var staffData)) continue;

                if (!unenchantedStavesByMagicSchool.TryGetValue(magicSchool, out var unenchantedStaff)) continue;

                stavesData.Add(new StaffData(book, spell, spellName, spellEditorID, magicSchool, magicLevel, unenchantedStaff, staffData.heartStoneCount, staffData.enchantmentAmount));
            }

            var claimedEnchantments = new HashSet<IObjectEffectGetter>();

            foreach (var staffData in stavesData)
            {
                staffData.EnchantmentEditorID = "StaffEnch" + staffData.SpellEditorID;

                if (staffEnchantmentsByEditorID.TryGetValue(staffData.EnchantmentEditorID, out staffData.Enchantment))
                    claimedEnchantments.Add(staffData.Enchantment);
            }

            IEnumerable<Effect> spellToStaffEffects(StaffData staffData)
            {
                // TODO filter and/or modify conditions.
                return staffData.Spell.Effects.Where(x => !x.BaseEffect.IsNull).Select(x => x.DeepCopy());
            }

            foreach (var staffData in stavesData)
            {
                if (staffData.Enchantment is not null) continue;

                var candidateEnchantments = new Dictionary<IObjectEffectGetter, int>();

                foreach (var magicEffect in staffData.Spell.Effects)
                {
                    var baseEffect = magicEffect.BaseEffect;
                    if (baseEffect.IsNull) continue;
                    if (staffEnchantmentsByMagicEffect.TryGetValue(NewFormLink(baseEffect), out var candidateEnchantments1))
                    {
                        foreach (var candidateEnchantment in candidateEnchantments1)
                        {
                            if (claimedEnchantments.Contains(candidateEnchantment)) continue;
                            candidateEnchantments.TryGetValue(candidateEnchantment, out var count);
                            candidateEnchantments[candidateEnchantment] = count + 1;
                        }
                    }
                }

                foreach (var candidateEnchantment in candidateEnchantments.OrderBy(x => x.Value))
                {
                    // TODO how do we pick the right one?
                    staffData.Enchantment = candidateEnchantment.Key;
                    claimedEnchantments.Add(candidateEnchantment.Key);
                    break;
                }

                if (staffData.Enchantment is not null)
                {
                    if (candidateEnchantments.Count > 1)
                    {
                        Console.WriteLine($"For the spell {PrettyPrintMajorRecord(staffData.Spell)},");
                        Console.WriteLine($"selected {PrettyPrintMajorRecord(staffData.Enchantment)} from the other possibilities:");
                        foreach (var (candidateEnchanement, count) in candidateEnchantments)
                            if (candidateEnchanement != staffData.Enchantment)
                                Console.WriteLine(PrettyPrintMajorRecord(candidateEnchanement));
                        Console.WriteLine();
                    }
                    continue;
                }

                var newEnchantment = state.PatchMod.ObjectEffects.AddNew(staffData.EnchantmentEditorID);
                newEnchantment.Name = staffData.SpellName;
                newEnchantment.CastType = staffData.Spell.CastType;
                newEnchantment.TargetType = staffData.Spell.TargetType;
                newEnchantment.EnchantType = ObjectEffect.EnchantTypeEnum.StaffEnchantment;
                newEnchantment.Effects.AddRange(spellToStaffEffects(staffData));

                staffData.EnchantmentExisted = false;

                staffData.Enchantment = newEnchantment;
            }

            if (Settings.Value.CopySpellEffectsToExistingStaffEnchantments)
                foreach (var staffData in stavesData)
                {
                    if (staffData.Enchantment is null) throw new NullReferenceException(); // Can't happen.
                    if (!staffData.EnchantmentExisted) continue;
                    if (Settings.Value.StaffEnchantmentsNotToRefresh.Contains(staffData.Enchantment)) continue;

                    var modifiedEnchantment = state.PatchMod.ObjectEffects.GetOrAddAsOverride(staffData.Enchantment);
                    modifiedEnchantment.Name = staffData.SpellName;
                    modifiedEnchantment.CastType = staffData.Spell.CastType;
                    modifiedEnchantment.TargetType = staffData.Spell.TargetType;
                    modifiedEnchantment.Effects.Clear();
                    modifiedEnchantment.Effects.AddRange(spellToStaffEffects(staffData));

                    // TODO if no change made, don't copy.

                    staffData.Enchantment = modifiedEnchantment;
                }

            var claimedStaves = new HashSet<IWeaponGetter>();

            foreach (var staffData in stavesData)
            {
                staffData.StaffEditorID = "Staff" + staffData.SpellEditorID;

                if (stavesByEditorID.TryGetValue(staffData.StaffEditorID, out staffData.Staff))
                    claimedStaves.Add(staffData.Staff);
            }

            var newStavesByHalfCostPerk = new Dictionary<FormLink<IPerkGetter>, List<IWeapon>>();

            foreach (var staffData in stavesData)
            {
                if (staffData.Staff is not null) continue;
                if (staffData.Enchantment is null)
                    throw new NullReferenceException("Can't happen");

                if (enchantedStavesByEnchantment.TryGetValue(NewFormLink<IEffectRecordGetter>(staffData.Enchantment), out var candidateStaves))
                {
                    var unenchantedStaffLink = staffData.UnenchantedStaff.AsLink();

                    var filteredCandidates = (
                        from candidateStaff in candidateStaves
                        where !claimedStaves.Contains(candidateStaff)
                        where candidateStaff.Template == unenchantedStaffLink
                        select candidateStaff
                    ).ToList();

                    foreach (var candidateStaff in filteredCandidates)
                    {
                        if (candidateStaff.EditorID?.Equals(staffData.StaffEditorID, StringComparison.OrdinalIgnoreCase) != true) continue;
                        claimedStaves.Add(candidateStaff);
                        staffData.Staff = candidateStaff;
                        break;
                    }

                    if (staffData.Staff is null)
                        foreach (var candidateStaff in filteredCandidates)
                        {
                            // TODO add more criteria?
                            claimedStaves.Add(candidateStaff);
                            staffData.Staff = candidateStaff;
                            break;
                        }

                    if (staffData.Staff is not null && filteredCandidates.Count > 1)
                    {
                        Console.WriteLine($"For the spell {PrettyPrintMajorRecord(staffData.Spell)},");
                        Console.WriteLine($"Selected {PrettyPrintMajorRecord(staffData.Staff)} from the other possibilities:");
                        foreach (var candidateStaff in filteredCandidates)
                            if (candidateStaff != staffData.Staff)
                                Console.WriteLine(PrettyPrintMajorRecord(candidateStaff));
                        Console.WriteLine();
                    }
                }

                if (staffData.Staff is not null) { 
                    continue; 
                }

                var newStaff = state.PatchMod.Weapons.AddNew(staffData.StaffEditorID);
                staffData.StaffExisted = false;
                newStaff.DeepCopyIn(staffData.UnenchantedStaff, new Weapon.TranslationMask(true)
                {
                    EditorID = false,
                    Name = false,
                    Template = false,
                    ObjectEffect = false,
                    EnchantmentAmount = false
                });

                newStaff.Name = Settings.Value.StaffNamePrefix + staffData.SpellName + Settings.Value.StaffNameSuffix;
                newStaff.Template = NewFormLinkNullable(staffData.UnenchantedStaff);
                newStaff.ObjectEffect = NewFormLinkNullable<IEffectRecordGetter>(staffData.Enchantment);
                newStaff.EnchantmentAmount = staffData.EnchantmentAmount;
                if (Settings.Value.SetStaffPriceToSpellBookPrice)
                    (newStaff.BasicStats ??= new()).Value = staffData.Book.Value;

                (modifiedQAStaffContainer.Value.Items ??= new()).Add(new()
                {
                    Item = new()
                    {
                        Item = newStaff.AsLink<IItemGetter>(),
                        Count = 1
                    }
                });

                Autovivify(newStavesByHalfCostPerk, staffData.Spell.HalfCostPerk).Add(newStaff);

                staffData.Staff = newStaff;
            }

            foreach (var staffData in stavesData)
            {
                if (staffData.Staff is null)
                    throw new NullReferenceException("Can't happen");

                if (!staffData.StaffExisted) continue;

                if (!(Settings.Value.OverrideNamesOfExistingStaves || Settings.Value.SetStaffPriceToSpellBookPrice)) continue;

                var modifiedStaff = state.PatchMod.Weapons.GetOrAddAsOverride(staffData.Staff);

                if (Settings.Value.OverrideNamesOfExistingStaves)
                    modifiedStaff.Name = Settings.Value.StaffNamePrefix + staffData.SpellName + Settings.Value.StaffNameSuffix;
                
                if (Settings.Value.SetStaffPriceToSpellBookPrice)
                    (modifiedStaff.BasicStats ??= new()).Value = staffData.Book.Value;

                staffData.Staff = modifiedStaff;
            }

            foreach (var staffData in stavesData)
            {
                if (staffData.Staff is null)
                    throw new NullReferenceException("Can't happen");
                if (Settings.Value.StavesToNotRefreshRecipesFor.Contains(staffData.Staff)) continue;

                IConstructibleObject newRecipe;
                if (recipesByCreatedStaff.TryGetValue(staffData.Staff.FormKey, out var oldRrecipe))
                    newRecipe = state.PatchMod.ConstructibleObjects.GetOrAddAsOverride(oldRrecipe);
                else
                    newRecipe = state.PatchMod.ConstructibleObjects.AddNew("DLC2Recipe" + staffData.StaffEditorID);

                newRecipe.Items = makeNewRecipeIngredients(staffData.UnenchantedStaff, staffData.HeartStoneCount);

                newRecipe.Conditions.Clear();
                newRecipe.Conditions.Add(new ConditionFloat()
                {
                    CompareOperator = CompareOperator.EqualTo,
                    ComparisonValue = 1,
                    Data = new FunctionConditionData()
                    {
                        Function = (ushort)ConditionData.Function.HasSpell,
                        ParameterOneRecord = staffData.Spell.AsLink<ISkyrimMajorRecordGetter>(),
                        Unknown2 = 0,
                        Unknown3 = (int)Condition.RunOnType.Reference,
                        Unknown4 = 0x00000014, // PlayerRef [PLYR:000014]
                        Unknown5 = -1
                    }
                });
                newRecipe.CreatedObject = NewFormLinkNullable<IConstructibleGetter>(staffData.Staff);
                newRecipe.WorkbenchKeyword = Dragonborn.Keyword.DLC2StaffEnchanter;
                newRecipe.CreatedObjectCount = 1;
            }

            var leveledListByMagicLevel = new Dictionary<MagicLevel, ILeveledItem>();
            var modifiedLeveledListByFormKey = new Dictionary<FormKey, ILeveledItem>();

            // TODO add found staves if they're not in already in the leveled lists?
            foreach (var (halfCostPerkID, newStaves) in newStavesByHalfCostPerk)
            {
                var (magicSchool, magicLevel) = HalfCostPerkIDToMagicSchoolAndLevel[halfCostPerkID.FormKey];

                if (newStaves.Count > 1)
                    Console.WriteLine($"Adding {newStaves.Count} new {magicLevel} {magicSchool} staves to the appropriate leveled lists.");
                else
                    Console.WriteLine($"Adding {newStaves.Count} new {magicLevel} {magicSchool} staff to the appropriate leveled lists.");

                var leveledLists = new HashSet<ILeveledItemGetter>();
                var modifiedLeveledLists = new List<ILeveledItem>();

                if (HalfCostPerkIDToLevelledListIDs.TryGetValue(halfCostPerkID.FormKey, out var leveledListIDs))
                    leveledLists.UnionWith(leveledListIDs.Select(x => leveledListsByFormKey[x]));

                var magicLevelString = String.Format("{0:D2}", (int)magicLevel);

                var leveledListEditorID = $"LItemStaff{magicSchool:g}{magicLevelString}";
                if (leveledListsByEditorID.TryGetValue(leveledListEditorID, out var leveledList))
                    leveledLists.Add(leveledList);
                else
                {
                    var newLeveledList = state.PatchMod.LeveledItems.AddNew(leveledListEditorID);
                    newLeveledList.ChanceNone = 0;
                    newLeveledList.Flags = LeveledItem.Flag.CalculateForEachItemInCount | LeveledItem.Flag.CalculateFromAllLevelsLessThanOrEqualPlayer;

                    (Autovivify(leveledListByMagicLevel, magicLevel, () => state.PatchMod.LeveledItems.GetOrAddAsOverride(leveledListsByEditorID[$"LItemStaff{magicLevelString}"])).Entries ??= new()).Add(new()
                    {
                        Data = new()
                        {
                            Level = 1,
                            Reference = newLeveledList.AsLink<IItemGetter>(),
                            Count = 1,
                        }
                    });

                    modifiedLeveledLists.Add(newLeveledList);
                }

                foreach (var leveledList2 in leveledLists)
                    modifiedLeveledLists.Add(Autovivify(modifiedLeveledListByFormKey, leveledList2.FormKey, () => state.PatchMod.LeveledItems.GetOrAddAsOverride(leveledList2)));

                var leveledItems = newStaves.Select(staff => new LeveledItemEntry()
                {
                    Data = new()
                    {
                        Level = 1,
                        Reference = staff.AsLink<IItemGetter>(),
                        Count = 1,
                    }
                }).ToList();

                foreach (var leveledList3 in modifiedLeveledLists)
                    (leveledList3.Entries ??= new()).AddRange(leveledItems);
            }
        }

        private static Func<T, TResult> Memoize<T, TResult>(Func<T, TResult> func) where T : notnull
        {
            var cache = new ConcurrentDictionary<T, TResult>();
            return a => cache.GetOrAdd(a, func);
        }

        private static Func<T1, T2, TResult> Memoize<T1, T2, TResult>(Func<T1, T2, TResult> func)
        {
            var cache = new ConcurrentDictionary<(T1 a, T2 b), TResult>();
            return (a, b) => cache.GetOrAdd((a, b), (x) => func(x.a, x.b));
        }

        private static string PrettyPrintMajorRecord(IMajorRecordGetter record)
        {
            if (record is INamedGetter hasName)
                return $"{record.EditorID} \"{hasName.Name}\" {record.FormKey}";
            return $"{record.EditorID} {record.FormKey}";
        }

        private static V Autovivify<K, V>(IDictionary<K, V> dict, K key) where K : notnull where V : new() => Autovivify(dict, key, () => new());

        private static ImmutableHashSet<V>.Builder Autovivify<K, V>(IDictionary<K, ImmutableHashSet<V>.Builder> dict, K key) where K : notnull => Autovivify(dict, key, () => ImmutableHashSet.CreateBuilder<V>());

        private static V Autovivify<K, V>(IDictionary<K, V> dict, K key, Func<V> newThing) where K : notnull
        {
            if (!dict.TryGetValue(key, out var value))
                value = dict[key] = newThing();
            return value;
        }

        /*

        public static void RunPatch2(IPatcherState<ISkyrimMod, ISkyrimModGetter> state)
        {
            var spellIDsWithSpellBooks = state.LoadOrder.PriorityOrder.Book().WinningOverrides()
                .Select(book => book.Teaches)
                .OfType<IBookSpellGetter>()
                .Select(x => x.Spell)
                .ToHashSet();

            var learnableSpells = state.LoadOrder.PriorityOrder.Spell().WinningOverrides()
                .Where(spell => spell.Name is not null
                   && spell.EditorID is not null
                   && spell.Type == SpellType.Spell
                   && spell.TargetType != TargetType.Self
                   && AllowedCastTypes.Contains(spell.CastType)
                   && AllowedEquipmentTypes.Contains(spell.EquipmentType.FormKey)
                   // && ! forbiddenSpells.Contains(spell.FormKey)
                   && spellIDsWithSpellBooks.Contains(spell.FormKey))
                .ToDictionary(GetFormKey);

            var spellsByBaseEffectID = (
                from spell in learnableSpells.Values
                from effect in spell.Effects
                group spell by effect.BaseEffect.FormKey into spells
                where spells.Count() == 1
                select spells
            ).ToDictionary(x => x.Key, x => x.Single());

            var magicEffectsByFormKey = state.LoadOrder.PriorityOrder.MagicEffect().WinningOverrides()
                .ToDictionary(GetFormKey);

            var learnableMagicEffects = magicEffectsByFormKey.Values
                .Where(magicEffect => spellsByBaseEffectID.ContainsKey(magicEffect.FormKey))
                .ToDictionary(GetFormKey);

            var staffEnchantments = state.LoadOrder.PriorityOrder.ObjectEffect().WinningOverrides()
                .Where(enchantment => enchantment.EnchantType == ObjectEffect.EnchantTypeEnum.StaffEnchantment)
                .ToDictionary(GetFormKey);

            var staffEnchantmentsByEditorID = staffEnchantments.Values
                .Where(x => x.EditorID is not null)
                .ToDictionary(x => x.EditorID ?? "");

            var staffEnchantmentsByBaseEffectID = (
                from enchantment in staffEnchantments.Values
                from effect in enchantment.Effects
                group enchantment by effect.BaseEffect.FormKey into enchantments
                where enchantments.Count() == 1
                select enchantments
            ).ToDictionary(x => x.Key, x => x.Distinct().Single());

            var stavesByEnchantment = (
                from staff in state.LoadOrder.PriorityOrder.Weapon().WinningOverrides()
                where staff.Keywords?.Contains(Skyrim.Keyword.WeapTypeStaff) == true
                   && !staff.MajorFlags.HasFlag(Weapon.MajorFlag.NonPlayable)
                let isEnchanted = !staff.ObjectEffect.IsNull && staff.EnchantmentAmount > 0
                group staff by isEnchanted
            ).ToDictionary(x => x.Key, x => x.ToDictionary(GetFormKey));

            var enchantedStaves = stavesByEnchantment[true];
            var unenchantedStaves = stavesByEnchantment[false];

            var enchantedStavesByBaseEffectID = (
                from staff in enchantedStaves.Values
                group staff by staff.ObjectEffect.FormKey
            ).ToDictionary(x => x.Key, x => x.ToHashSet());

            var leveledListsByFormKey = state.LoadOrder.PriorityOrder.LeveledItem().WinningOverrides()
                .ToDictionary(GetFormKey);
            var leveledListsByEditorID = leveledListsByFormKey.Values
                .Where(llst => llst.EditorID is not null)
                .ToDictionary(llst => llst.EditorID ?? "");

            var DLC2BlankStaffLLST = leveledListsByFormKey[Dragonborn.LeveledItem.DLC2BlankStaff];

            HashSet<FormKey> blankStaves;
            try
            {
#pragma warning disable CS8604 // Possible null reference argument.
#pragma warning disable CS8602 // Dereference of a possibly null reference.
                blankStaves = DLC2BlankStaffLLST.Entries
                    .Select(entry => entry.Data.Reference.FormKey)
                    .ToHashSet();
#pragma warning restore CS8604 // Possible null reference argument.
#pragma warning restore CS8602 // Dereference of a possibly null reference.
            }
            catch (NullReferenceException e)
            {
                // can only happen if someone is being mean.
                throw RecordException.Factory(e, DLC2BlankStaffLLST);
            };

            var unenchantedStaffIDsByHalfCostPerk = (
                from staff in enchantedStaves.Values
                join templateStaff in unenchantedStaves
                  on staff.Template.FormKey equals templateStaff.Key
                where blankStaves.Contains(templateStaff.Key)
                join enchantment in staffEnchantments
                  on staff.ObjectEffect.FormKey equals enchantment.Key
                from effect in enchantment.Value.Effects
                join spell in spellsByBaseEffectID
                  on effect.BaseEffect.FormKey equals spell.Key
                group templateStaff.Value by spell.Value.HalfCostPerk.FormKey
            ).ToDictionary(x => x.Key, x => x.Distinct(GetFormKey).ToHashSet());

            var recipesByCreatedStaff = (
                from recipe in state.LoadOrder.PriorityOrder.ConstructibleObject().WinningOverrides()
                where recipe.CreatedObjectCount == 1
                let createdStaffID = recipe.CreatedObject.FormKey
                where enchantedStaves.ContainsKey(createdStaffID)
                group recipe by createdStaffID
            ).ToDictionary(x => x.Key, x => x.Single());

            var newStavesByHalfCostPerk = new Dictionary<FormKey, List<IWeapon>>();
            var recipeIngredientsByUnenchantedStaffID = new Dictionary<FormKey, ExtendedList<ContainerEntry>>();

            ConditionFloat? playerOnlyCondition = null;

            IEnumerable<Effect> copyAndModifySpellEffects(IEnumerable<IEffectGetter> spellEffects, IMajorRecordCommonGetter record)
            {
                List<Effect> enchantmentEffects = new();
                foreach (var spellEffect in spellEffects)
                {
                    if (spellEffect.Conditions
                        .OfType<IConditionFloatGetter>()
                        .Select(x => x.Data)
                        .OfType<IFunctionConditionDataGetter>()
                        .Any(x => conditionFunctionsAlwaysFalseUsingAStaff.Contains((ConditionData.Function)x.Function)))
                        continue;

                    if (!magicEffectsByFormKey.TryGetValue(spellEffect.BaseEffect.FormKey, out var magicEffect))
                        throw RecordException.Factory(new KeyNotFoundException(spellEffect.BaseEffect.ToString()), record);

                    if (magicEffect.Conditions
                        .OfType<IConditionFloatGetter>()
                        .Select(x => x.Data)
                        .OfType<IFunctionConditionDataGetter>()
                        .Any(x => conditionFunctionsAlwaysFalseUsingAStaff.Contains((ConditionData.Function)x.Function)))
                        continue;

                    var enchantmentEffect = spellEffect.DeepCopy();

                    foreach (var magicEffectCondition in magicEffect.Conditions)
                        if (magicEffectCondition is IConditionFloatGetter foo)
                            if (foo.Data is IFunctionConditionDataGetter bar)
                            {
                                ConditionData.Function function = (ConditionData.Function)bar.Function;
                                if (playerOnlyConditionFunctions.Contains(function))
                                {
                                    if (playerOnlyCondition is null)
                                        playerOnlyCondition = new ConditionFloat()
                                        {
                                            CompareOperator = CompareOperator.EqualTo,
                                            ComparisonValue = 1,
                                            Data = new FunctionConditionData()
                                            {
                                                Function = (ushort)ConditionData.Function.GetIsID,
                                                //ParameterOneRecord = 0x00000014,
                                                //run on caster.
                                            }
                                        };
                                    enchantmentEffect.Conditions.Add(playerOnlyCondition);
                                    throw RecordException.Factory(new NotImplementedException("Add condition to restict magic effect to player only."), record);
                                }
                                if (playerSpecificToCasterConditionFunctions.TryGetValue(function, out var newFunction))
                                {
                                    throw new NotImplementedException("Modify condition to apply to caster instead of player only.");
                                }
                            }

                    enchantmentEffects.Add(enchantmentEffect);
                }
                return enchantmentEffects;
            }

            foreach (var (spellID, spell) in learnableSpells)
            {
                var spellEditorID = spell.EditorID;

                var enchantmentEditorID = "StaffEnch" + spell.EditorID;
                var enchantmentName = spell.Name?.String;
                if (!staffEnchantmentsByEditorID.TryGetValue(enchantmentEditorID, out var enchantment))
                {
                    var newEnchantment = state.PatchMod.ObjectEffects.AddNew(enchantmentEditorID);
                    newEnchantment.Name = enchantmentName;
                    newEnchantment.CastType = spell.CastType;
                    newEnchantment.TargetType = spell.TargetType;
                    newEnchantment.EnchantType = ObjectEffect.EnchantTypeEnum.StaffEnchantment;
                    newEnchantment.Effects.AddRange(copyAndModifySpellEffects(spell.Effects, spell));

                    enchantment = newEnchantment;
                }
                else
                {
                    bool enchantmentAndSpellEffectsIdentical = true;
                    enchantmentAndSpellEffectsIdentical = spell.Effects.Equals(enchantment.Effects);
                    enchantmentAndSpellEffectsIdentical = false;

                    if (enchantment.Name?.String != enchantmentName
                        || enchantment.CastType != spell.CastType
                        || enchantment.TargetType != spell.TargetType
                        || !enchantmentAndSpellEffectsIdentical)
                    {
                        var modifiedEnchantment = state.PatchMod.ObjectEffects.GetOrAddAsOverride(enchantment);

                        modifiedEnchantment.Name = enchantmentName;
                        modifiedEnchantment.CastType = spell.CastType;
                        modifiedEnchantment.TargetType = spell.TargetType;

                        if (!enchantmentAndSpellEffectsIdentical)
                        {
                            modifiedEnchantment.Effects.Clear();
                            modifiedEnchantment.Effects.AddRange(copyAndModifySpellEffects(spell.Effects, spell));
                        }

                        enchantment = modifiedEnchantment;
                    }
                }

                throw new NotImplementedException();
            }

            // TODO foreach spell in spells ...
            foreach (var (effectId, effect) in learnableMagicEffects)
            {
                // should never happen
                if (!spellsByBaseEffectID.TryGetValue(effectId, out var spell)) continue;

                var halfCostPerkID = spell.HalfCostPerk.FormKey;

                // also should never happen...
                if (!unenchantedStaffIDsByHalfCostPerk.TryGetValue(halfCostPerkID, out var unenchantedStaves2)) continue;

                // TODO if we have multiple results, create a new staff for each template staff?
                IWeaponGetter unenchantedStaff = unenchantedStaves2.First();

                // create new staff enchantment if missing
                if (!staffEnchantmentsByBaseEffectID.TryGetValue(effectId, out var enchantment))
                {
                    var enchantmentEditorId = "StaffEnch" + spell.EditorID;
                    var newEnchantment = state.PatchMod.ObjectEffects.AddNew(enchantmentEditorId);
                    newEnchantment.Name = spell.Name?.String;
                    newEnchantment.CastType = spell.CastType;
                    newEnchantment.TargetType = spell.TargetType;
                    newEnchantment.EnchantType = ObjectEffect.EnchantTypeEnum.StaffEnchantment;
                    newEnchantment.Effects.Add(spell.Effects.Where(x => x.BaseEffect.FormKey == effectId).First().DeepCopy());

                    enchantment = newEnchantment;
                }

                IWeaponGetter staff;

                // create new staff if missing
                if (enchantedStavesByBaseEffectID.TryGetValue(effectId, out var staves))
                {
                    staff = (
                        from staff2 in staves
                        where unenchantedStaves.ContainsKey(staff2.Template.FormKey)
                        select staff2
                    ).Single();
                }
                else
                {
                    var staffEditorID = "Staff" + spell.EditorID;
                    var newStaff = state.PatchMod.Weapons.AddNew(staffEditorID);
                    // TODO translations?
                    newStaff.Name = "Staff of " + spell.Name?.String;
                    newStaff.Template = NewFormLinkNullable(unenchantedStaff);
                    newStaff.ObjectEffect = NewFormLinkNullable<IEffectRecordGetter>(enchantment);
                    // TODO other stuff?

                    if (!newStavesByHalfCostPerk.TryGetValue(halfCostPerkID, out var addedStaves))
                        addedStaves = newStavesByHalfCostPerk[halfCostPerkID] = new();
                    addedStaves.Add(newStaff);

                    staff = newStaff;
                }

                if (!recipeIngredientsByUnenchantedStaffID.TryGetValue(unenchantedStaff.FormKey, out var newRecipeIngredients))
                    newRecipeIngredients = recipeIngredientsByUnenchantedStaffID[unenchantedStaff.FormKey] = new()
                    {
                        new()
                        {
                            Item = new()
                            {
                                Item = unenchantedStaff.AsLink<IItemGetter>(),
                                Count = 1
                            }
                        },
                        new()
                        {
                            Item = new()
                            {
                                Item = Dragonborn.MiscItem.DLC2HeartStone,
                                Count = 3
                            }
                        }
                    };

                // (re)build recipe
                IConstructibleObject newRecipe;
                if (recipesByCreatedStaff.TryGetValue(staff.FormKey, out var oldRrecipe))
                    newRecipe = state.PatchMod.ConstructibleObjects.GetOrAddAsOverride(oldRrecipe);
                else
                    newRecipe = state.PatchMod.ConstructibleObjects.AddNew("DLC2Recipe" + staff.EditorID);

                newRecipe.Items = newRecipeIngredients;
                newRecipe.Conditions.Clear();
                newRecipe.Conditions.Add(new ConditionFloat()
                {
                    CompareOperator = CompareOperator.EqualTo,
                    ComparisonValue = 1,
                    Data = new FunctionConditionData()
                    {
                        Function = (ushort)ConditionData.Function.HasSpell,
                        ParameterOneRecord = spell.AsLink<ISkyrimMajorRecordGetter>(),
                        Unknown2 = 0,
                        Unknown3 = (int)Condition.RunOnType.Reference,
                        Unknown4 = 0x00000014, // PlayerRef [PLYR:000014]
                        Unknown5 = 0
                    }
                });
                newRecipe.CreatedObject = NewFormLinkNullable<IConstructibleGetter>(staff);
                newRecipe.WorkbenchKeyword = Dragonborn.Keyword.DLC2StaffEnchanter;
                newRecipe.CreatedObjectCount = 1;
            }

            var leveledListByMagicLevel = new Dictionary<MagicLevel, ILeveledItem>();
            var modifiedLeveledListByFormKey = new Dictionary<FormKey, ILeveledItem>();

            foreach (var (halfCostPerkID, newStaves) in newStavesByHalfCostPerk)
            {
                var leveledLists = new HashSet<ILeveledItemGetter>();
                var modifiedLeveledLists = new List<ILeveledItem>();

                if (HalfCostPerkIDToLevelledListIDs.TryGetValue(halfCostPerkID, out var leveledListIDs))
                    foreach (var leveledListFormKey in leveledListIDs)
                        if (leveledListsByFormKey.TryGetValue(leveledListFormKey, out var leveledList))
                            leveledLists.Add(leveledList);

                if (HalfCostPerkIDToLeveledListData.TryGetValue(halfCostPerkID, out var editorIdFoo))
                {
                    var (magicSchool, magicLevel) = editorIdFoo;

                    var magicLevelString = String.Format("{0:D2}", (int)magicLevel);

                    var leveledListEditorID = $"LItemStaff{magicSchool:g}{magicLevelString}";
                    if (leveledListsByEditorID.TryGetValue(leveledListEditorID, out var leveledList))
                        leveledLists.Add(leveledList);
                    else
                    {
                        var newLeveledList = state.PatchMod.LeveledItems.AddNew(leveledListEditorID);
                        newLeveledList.ChanceNone = 0;
                        newLeveledList.Flags = LeveledItem.Flag.CalculateForEachItemInCount | LeveledItem.Flag.CalculateFromAllLevelsLessThanOrEqualPlayer;

                        if (!leveledListByMagicLevel.TryGetValue(magicLevel, out var leveledListForMagicLevel))
                        {
                            var leveledListForMagicLevelEditorID = $"LItemStaff{magicLevelString}";
                            if (!leveledListsByEditorID.TryGetValue(leveledListForMagicLevelEditorID, out var leveledListForMagicLevelGetter))
                                throw new KeyNotFoundException($"LeveledList defined in Skyrim.esm \"{leveledListForMagicLevelEditorID}\" couldn't be found?");
                            leveledListForMagicLevel = leveledListByMagicLevel[magicLevel] = state.PatchMod.LeveledItems.GetOrAddAsOverride(leveledListForMagicLevelGetter);
                        }
                        leveledListForMagicLevel.Entries ??= new();
                        leveledListForMagicLevel.Entries.Add(new()
                        {
                            Data = new()
                            {
                                Level = 1,
                                Reference = newLeveledList.AsLink<IItemGetter>(),
                                Count = 1,
                            }
                        });

                        modifiedLeveledLists.Add(newLeveledList);
                    }
                }

                foreach (var leveledList in leveledLists)
                {
                    if (!modifiedLeveledListByFormKey.TryGetValue(leveledList.FormKey, out var modifiedLeveledList))
                        modifiedLeveledList = modifiedLeveledListByFormKey[leveledList.FormKey] = state.PatchMod.LeveledItems.GetOrAddAsOverride(leveledList);
                    modifiedLeveledLists.Add(modifiedLeveledList);
                }

                var leveledItems = newStaves.Select(staff => new LeveledItemEntry()
                {
                    Data = new()
                    {
                        Level = 1,
                        Reference = staff.AsLink<IItemGetter>(),
                        Count = 1,
                    }
                }).ToList();

                foreach (var leveledList in modifiedLeveledLists)
                    (leveledList.Entries ??= new()).AddRange(leveledItems);
            }
        
        }
    */
    }
}
